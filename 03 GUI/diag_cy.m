function [ax_obj, text_list, fwh_cords, tur_cords, other_txts] = diag_cy(cycle,c_list,ax,draw_text)
%diag_cy Draw a diagram of a cycle and return the ax object
%   Inputs:
%           -> cycle: cycle to draw
%           -> c_list: List of cross text objects for renaming
%           -> ax: Axes object in which to draw
%           -> draw_text: boolean, if true draw text and crosses
%   Outputs:
%           -> ax_obj: Axes object where the diagram was drawn
%           -> text_resize_arr: List of handles to text object, used for
%           resizing. List is of the list_cell class
%           -> fwh_cords: FWH GUI objects

% Get number of feed water heaters
fwh_hp=cycle.N_FWH_HP;
fwh_lp=cycle.N_FWH_LP;

IP_in_pos=find(cycle.EX_d(2,:)==2);
LP_in_pos=find(cycle.EX_d(2,:)==3);

ex_HPT=sum(cycle.EX_d(2,1:IP_in_pos)==0);
ex_IPT=sum(cycle.EX_d(2,IP_in_pos:LP_in_pos)==0);

% Only rewrite option
if nargin==2
    % Rewrite text objects
    rewrite(cycle,c_list);
    
    % Exit function
    return
end

% Draw in ax a diagram of cycle
% Cross fontsize
cross_fontsize=0.02;

% FWH TTD DCA fontsize
TTDDCA_fontsize=0.018;

% Textbox fontsize
txtbox_fontsize=0.02;

% Leaks text fontsize
leaks_fontsize=0.02;

% FWH position
if (fwh_hp+fwh_lp)<=6
    base_dist=190; % FWH base dist
    dist_deair=15; % Distance to deareator
elseif (fwh_hp+fwh_lp)<=8
    base_dist=210;
    dist_deair=17; % Distance to deareator
else
    base_dist=240;
    dist_deair=17; % Distance to deareator
end

fwh_size=9;
ini_pos=20;
dist=base_dist/(fwh_hp+fwh_lp+1); % Distance between FWHs

% Cross text array, for changing numeric values
text_list=list_cell(50,4);

other_txts=list_cell(10,1);

% Draw turbines
if ex_HPT<=1
    % Default HP Turbine width    
    HPIP_width=80;
    ang_HP=13.5;
    HP_width=0.21;
    IP_width=0.5;
elseif ex_IPT==0
    % Extra-wide HP Turbine
    HPIP_width=80;
    ang_HP=8;
    HP_width=0.41;
    IP_width=0.3;
else
    % Extra-wide HPIP Turbine
    HPIP_width=100;
    ang_HP=8;
    HP_width=0.3;
    IP_width=0.41;    
end    

turHPIP=gui_turHPIP(HPIP_width,30,ang_HP,8,ex_HPT,fwh_hp+1-ex_HPT,HP_width,IP_width);
turHPIP.draw(ax,20,60);

turLP=gui_turLP(80,21,8,fwh_lp);
turLP.draw(ax,HPIP_width+40,60);

% Connect turbines and draw text
connect(ax,turHPIP.IP_out_up,...
    turLP.in,...
    [turLP.in(1)-20,turLP.in(2)+10],...
    true, 2.333, 'hor');

if draw_text    
    % HP Turbine inlet after throttle and full out text
    text_list.add(cross(ax, turHPIP.tHP_in,...
        cycle.tur{1}.adm_EX(2),...
        cycle.m_fw,...
        cycle.tur{1}.adm_h(2),...
        cycle.tur{1}.adm_T(2)-273,...
        cross_fontsize));
    
    % IP Turbine inlet before intercept Valve
    text_list.add(cross(ax, turHPIP.tIP_in+[0,10],...
        cycle.tur{2}.adm_EX(1),...
        cycle.tur{2}.m_in,...
        cycle.tur{2}.adm_h(1),...
        cycle.tur{2}.adm_T(1)-273,...
        cross_fontsize));
    
    % IP Turbine inlet after intercept Valve
    text_list.add(cross(ax, turHPIP.tIP_in+[0,-1],...
        cycle.tur{2}.adm_EX(2),...
        cycle.tur{2}.m_in,...
        cycle.tur{2}.adm_h(2),...
        cycle.tur{2}.adm_T(2)-273,...
        cross_fontsize));
    
    % LP Turbine inlet
    text_list.add(cross(ax, turLP.tin,...
        cycle.tur{2}.EX(1,cycle.tur{2}.XO_pos),...
        cycle.tur{2}.m_in-sum(cycle.tur{2}.m_EX(1:cycle.tur{2}.XO_pos)),...
        cycle.tur{2}.h_st(cycle.tur{2}.XO_pos),...
        cycle.tur{2}.T_st(cycle.tur{2}.XO_pos)-273,...
        cross_fontsize));
    
    % LP Turbine exhaust
    text_list.add(cross(ax, turHPIP.tHP_out_full,...
        cycle.tur{1}.EX(1,end),...
        cycle.tur{1}.m_out+cycle.tur{1}.m_EX(end),...
        cycle.tur{1}.h_st(end),...
        cycle.tur{1}.T_st(end)-273,...
        cross_fontsize));
    
    % Extractions
    for e=1:ex_HPT
        
        % Apply correction if 2 extractions in HPT
        offset=[0,0];
        if e==2
            offset=[ini_pos+dist+fwh_size/2+0.5-turHPIP.tHP_out(e,1),-5];
        end
        
        text_list.add(cross(ax, turHPIP.tHP_out(e,:)+offset,...
            cycle.tur{1}.EX(1,e+1),...
            cycle.tur{1}.m_EX(e+1),...
            cycle.tur{1}.h_st(e+1),...
            cycle.tur{1}.T_st(e+1)-273,...
            cross_fontsize));
    end
    
    for e=1:fwh_hp+1-ex_HPT
        text_list.add(cross(ax, turHPIP.tIP_out(e,:),...
            cycle.tur{2}.EX(1,e+1),...
            cycle.tur{2}.m_EX(e+1),...
            cycle.tur{2}.h_st(e+1),...
            cycle.tur{2}.T_st(e+1)-273,...
            cross_fontsize));
    end
    
    for e=1:fwh_lp
        text_list.add(cross(ax, turLP.tout(e,:),...
            cycle.tur{2}.EX(1,e+1+fwh_hp+1-ex_HPT),...
            cycle.tur{2}.m_EX(e+1+fwh_hp+1-ex_HPT),...
            cycle.tur{2}.h_st(e+1+fwh_hp+1-ex_HPT),...
            cycle.tur{2}.T_st(e+1+fwh_hp+1-ex_HPT)-273,...
            cross_fontsize));
    end
end

% Draw FWHs and feedwater pump, and connect them to the turbines
fwh=cell(1,fwh_hp+fwh_lp+1);
x_pos=ini_pos;

vlv_drainback=gui_valve(4,2);

for i=1:(fwh_hp+fwh_lp+1)
    fwh{i}=gui_fwh(fwh_size,fwh_size);
    
    % Position in fwh cell in cycle
    if i<=fwh_hp
        pos=i;
    else
        pos=i-1;
    end
    
    if i==fwh_hp+1
        % Deareator
        x_pos=x_pos+dist_deair;
        fwh{i}.draw(ax,x_pos,20,0);
        
        % Feedwater pump
        fw_pmp=gui_pmp(2.5);
        fw_pmp.draw(ax,x_pos-17.5,20+fwh_size/2-2.5,180);
    else
        if draw_text
            % FWHs
            TTD=cycle.fwh{pos}.TTD;
            DCA=cycle.fwh{pos}.DCA;
            
            bypass=cycle.fwh{pos}.bypass;
            
            % Special case
            if DCA==-1
                bypass=1;
            end
        end        
        
        fwh{i}.draw(ax,x_pos,20,1);
        
        if draw_text
            text_list.add(fwh{i}.draw_TTDDCA(ax,TTD,DCA,bypass,TTDDCA_fontsize));
        end
        
    end
    
    x_pos=x_pos+dist;
    
    % Connect
    if i<=ex_HPT
        % HP Turbine extractions
        
        interrupt=[];
        if i==1
            mid_point=(turHPIP.HP_out(i,:)+fwh{i}.Hot_in)/2+[0,2];
            
            if ex_HPT>1
                interrupt=[turHPIP.HP_out(i+1,1),mid_point(2)];
            end
            
        else
            mid_point=(turHPIP.HP_out(i,:)+fwh{i}.Hot_in)/2;
        end
        
        connect(ax,turHPIP.HP_out(i,:),...
            fwh{i}.Hot_in,...
            mid_point,...
            true, 2.333, 'hor',interrupt);
        
    elseif i<=fwh_hp+1
        % IP Turbine extractions + deareator
        if i==fwh_hp+1
            mid_point=(turHPIP.IP_out(i-ex_HPT,:)+fwh{i}.Hot_in)/2+[0,4];
        else
            mid_point=-1;
        end
        
        connect(ax,turHPIP.IP_out(i-ex_HPT,:),...
            fwh{i}.Hot_in,...
            mid_point,...
            true, 2.333, 'hor');
        
    else
        p1=turLP.out(i-(fwh_hp+1),:);
        p2=fwh{i}.Hot_in;
        p3=[(p1(1)+p2(1))*0.5, p2(2)+(p1(2)-p2(2))*(0.3+0.4*(i-fwh_hp-1)/fwh_lp)];
        connect(ax,p1,...
            p2,...
            p3,...
            true, 2.333, 'hor');
    end
    
    if i>1
        % Cold line to previous fwh
        if i==fwh_hp+1
            % Deareator
            connect(ax,fwh{i}.Cold_out,...
                fw_pmp.in,...
                -1,...
                true, 2.333, 'hor');
            
            connect(ax,fw_pmp.out,...
                fwh{i-1}.Cold_in,...
                -1,...
                true, 2.333, 'hor');
            
        else
            connect(ax,fwh{i}.Cold_out,...
                fwh{i-1}.Cold_in,...
                -1,...
                true, 2.333, 'hor');
        end
        
        % Drainback
        if ((i<=fwh_hp+1) || (i>fwh_hp+2))
            vlv_drainback.draw(ax,fwh{i-1}.Hot_out+[13.5,-7],'hor');
            
            connect(ax,fwh{i-1}.Hot_out,...
                vlv_drainback.left,...
                [fwh{i-1}.Hot_out(1)+1, vlv_drainback.left(2)],...
                true, 2.333, 'hor');
            
            connect(ax,vlv_drainback.right,...
                fwh{i}.Db_in,...
                [vlv_drainback.right(1)+1, vlv_drainback.right(2)],...
                true, 2.333, 'hor');
        end
    end
    
    if draw_text
        % FWH text
        if (i<=fwh_hp) || (i>fwh_hp+1)
            % FWHs
            if pos==fwh_hp+fwh_lp
                text_list.add(cross(ax, fwh{i}.tCold_in,...
                    cycle.fwh{pos}.P_C,...
                    cycle.fwh{pos}.mciclo,...
                    cycle.fwh{pos}.h_Cin,...
                    cycle.fwh{pos}.T_Cin-273,...
                    cross_fontsize));
            end            
            
            text_list.add(cross(ax, fwh{i}.tCold_out,...
                cycle.fwh{pos}.P_C,...
                cycle.fwh{pos}.mciclo,...
                cycle.fwh{pos}.h_Cout,...
                cycle.fwh{pos}.T_Cout-273,...
                cross_fontsize));
            
            text_list.add(cross(ax, fwh{i}.tHot_out,...
                cycle.fwh{pos}.P_ex,...
                cycle.fwh{pos}.md+cycle.fwh{pos}.mex,...
                cycle.fwh{pos}.h_Hout,...
                cycle.fwh{pos}.T_Hout-273,...
                cross_fontsize));
            
            text_list.add(cross(ax, fwh{i}.tHot_in,...
                cycle.fwh{pos}.P_ex,...
                cycle.fwh{pos}.mex,...
                cycle.fwh{pos}.h_ex,...
                cycle.fwh{pos}.T_Hin-273,...
                cross_fontsize));
        else
            % Deareator
            text_list.add(cross(ax, fwh{i}.tCold_out,...
                cycle.P_COpmp,...
                cycle.m_fw,...
                cycle.h_DA_out,...
                cycle.T_DA_out-273,...
                cross_fontsize));
            
            text_list.add(cross(ax, fwh{i}.tHot_in,...
                cycle.P_COpmp,...
                cycle.m_DA_mix,...
                cycle.h_DA_mix,...
                cycle.T_DA_mix-273,...
                cross_fontsize));
            
            text_list.add(cross(ax, fw_pmp.tout,...
                cycle.fw_pmp.P_out,...
                cycle.fw_pmp.m_in,...
                cycle.fw_pmp.h_out,...
                cycle.fw_pmp.T_out-273,...
                cross_fontsize));
            
        end
    end
end

% Draw condenser, condenser pump and LP out
con = gui_con(8,8);
con.draw(ax,x_pos-dist+23,45);

% Condensate pump
co_pmp=gui_pmp(2.5);
co_pmp.draw(ax,x_pos-dist+23+1.5,30,270);

connect(ax,turLP.out_end,...
    con.in,...
    turLP.out_end+[1,0],...
    true, 2.333, 'hor');

connect(ax,con.out,...
    co_pmp.in,...
    -1,...
    true, 2.333, 'hor');

connect(ax,co_pmp.out,...
    fwh{end}.Cold_in,...
    fwh{end}.Cold_in+[1,0],...
    true, 2.333, 'hor');

if draw_text
    text_list.add(cross(ax, con.tin,...
        cycle.tur{2}.EX(1,end),...
        cycle.tur{2}.m_out,...
        cycle.tur{2}.h_st(end),...
        cycle.tur{2}.T_st(end)-273,...
        cross_fontsize));
    
    text_list.add(cross(ax, con.tout,...
        cycle.co_pmp.P_in,...
        cycle.co_pmp.m_in,...
        cycle.co_pmp.h_in,...
        cycle.co_pmp.T_in-273,...
        cross_fontsize));
end

% Connect last FWH to HP turbine
htr_box = txt_box(5,2.5,'HTR');
other_txts.add(htr_box.draw(ax,fwh{1}.Cold_out+[-15,0]+[-5,-2.5/2],txtbox_fontsize));

connect(ax,fwh{1}.Cold_out,...
    htr_box.right,...
    -1,...
    true, 2.333, 'hor');

% Connect HTR to HP turbine. Draw valve
other_txts.add(htr_box.draw(ax,turHPIP.HP_in+[-33,4]+[-5,-2.5/2],txtbox_fontsize));

vlv_throttle = gui_valve(4,2);
if draw_text
    other_txts.add(vlv_throttle.draw(ax,turHPIP.HP_in+[-35/2-2,4-2/2],'hor',...
        'TV','down',txtbox_fontsize));
else
    vlv_throttle.draw(ax,turHPIP.HP_in+[-35/2-2,4-2/2],'hor');
end

connect(ax,htr_box.right,...
    vlv_throttle.left,...
    -1,...
    true, 2.333, 'hor');

connect(ax,vlv_throttle.right,...
    turHPIP.HP_in,...
    turHPIP.HP_in+[-5,+4],...
    true, 2.333, 'hor');

if draw_text
    % Heater output
    text_list.add(cross(ax, turHPIP.tHP_in+[-18,0],...
        cycle.P_HTR,...
        cycle.m_fw,...
        cycle.tur{1}.adm_h(1),...
        cycle.T_HTR-273,...
        cross_fontsize));
end

% Connect last FWH to condenser
vlv_drainback.draw(ax,fwh{end}.Hot_out+[13.5,-7],'hor');

connect(ax,fwh{end}.Hot_out,...
    vlv_drainback.left,...
    [fwh{end}.Hot_out(1)+1, vlv_drainback.left(2)],...
    true, 2.333, 'hor');

connect(ax,vlv_drainback.right,...
    con.in_DB+[0,-21],...
    vlv_drainback.right+[1,0],...
    false, 2.333, 'hor');

connect(ax,con.in_DB+[0,-20],...
    con.in_DB,...
    -1,...
    true, 2.333, 'hor');

% Connect HP to IP
rhtr_box = txt_box(6.5,2.5,'RHTR');
other_txts.add(rhtr_box.draw(ax,[turHPIP.IP_in(1)-20,turHPIP.HP_in(2)+5.3],txtbox_fontsize));

connect(ax,turHPIP.HP_out(end,:)+[0,-7],...
    rhtr_box.left,...
    turHPIP.HP_out(end,:)+[-25,20],...
    true, 2.333, 'ver');

% Draw Intercept valve before IP turbine
vlv_intercept = gui_valve(2,4);
if draw_text
    other_txts.add(vlv_intercept.draw(ax,turHPIP.IP_in+[-1,9],'ver',...
        'IV','right',txtbox_fontsize));
else
    vlv_intercept.draw(ax,turHPIP.IP_in+[-1,9],'ver');
end

connect(ax,rhtr_box.right,...
    vlv_intercept.top,...
    rhtr_box.right+[1,0],...
    true, 2.333, 'hor');

connect(ax,vlv_intercept.bottom,...
    turHPIP.IP_in,...
    -1,...
    true, 2.333, 'hor');

if draw_text
    % Draw leakage mass flows
    text_list.add(leaks_draw(ax, [90,95], cycle.tur{1}.m_Leaks,leaks_fontsize));
end

% Draw leakage text box indicators
A_box = txt_box(2.5,2.5,'A');
other_txts.add(A_box.draw(ax,turHPIP.A_leak+[-10,-2.5/2],txtbox_fontsize));

connect(ax,turHPIP.A_leak,...
    A_box.right,...
    -1,...
    true, 2.333, 'hor');

B_box = txt_box(2.5,2.5,'B');
other_txts.add(B_box.draw(ax,turHPIP.B_leak+[2,5],txtbox_fontsize));

connect(ax,turHPIP.B_leak,...
    B_box.bottom,...
    B_box.bottom+[0,-1.5],...
    true, 2.333, 'ver');

connect(ax,B_box.top,...
    [turHPIP.IP_in(1),B_box.top(2)+7.5],...
    B_box.top+[0,7.5],...
    true, 2.333, 'hor');

L1_box = txt_box(2.5,2.5,'1');
other_txts.add(L1_box.draw(ax,turHPIP.L1_leak+[1.5,-2.5/2],txtbox_fontsize));

connect(ax,L1_box.right,...
    L1_box.right+[2.5,0],...
    -1,...
    true, 1.5, 'hor');

L3_box = txt_box(2.5,2.5,'3');
other_txts.add(L3_box.draw(ax,turHPIP.L3_leak+[-1-2.5,-2.5/2],txtbox_fontsize));

connect(ax,L3_box.left,...
    L3_box.left+[-3,0],...
    -1,...
    true, 1.5, 'hor');

L4_box = txt_box(2.5,2.5,'4');
other_txts.add(L4_box.draw(ax,turHPIP.L4_leak+[-2.5/2,-8],txtbox_fontsize));

connect(ax,turHPIP.L4_leak,...
    L4_box.top,...
    -1,...
    true, 2.333, 'hor');

L6_box = txt_box(2.5,2.5,'6');
other_txts.add(L6_box.draw(ax,turHPIP.L6_leak+[-2.5/2,-8],txtbox_fontsize));

connect(ax,turHPIP.L6_leak,...
    L6_box.top,...
    -1,...
    true, 2.333, 'hor');

DEAIR_box = txt_box(7,2.5,'DEAIR');
other_txts.add(DEAIR_box.draw(ax,turHPIP.toDEAIR_leak+[-2.5/2-5.3,-12],txtbox_fontsize));

connect(ax,turHPIP.toDEAIR_leak,...
    [turHPIP.toDEAIR_leak(1), DEAIR_box.top(2)],...
    -1,...
    true, 2.333, 'hor');

other_txts.add(DEAIR_box.draw(ax,fwh{fwh_hp+1}.Hot_in+[5,10],txtbox_fontsize));

connect(ax,DEAIR_box.left,...
    [fwh{fwh_hp+1}.Hot_in(1), DEAIR_box.left(2)],...
    -1,...
    true, 2.333, 'hor');

% Draw leaks to condensator
leaks_to_con = txt_box(7,2.5,'A, 4, 6');
other_txts.add(leaks_to_con.draw(ax,con.left+[-13,-2.5/2],txtbox_fontsize));

connect(ax,leaks_to_con.right,...
    con.left,...
    -1,...
    true, 2.333, 'hor');

% Draw PLoss values
if draw_text
    % Extraction lines loss
    for i=1:(fwh_hp+fwh_lp+1)

        if i==fwh_hp+1
            ploss=cycle.DAEX_ploss;
        elseif i<fwh_hp+1
            ploss=cycle.EX_ploss(i);
        else
            ploss=cycle.EX_ploss(i-1);
        end
        
        txt_obj=text(fwh{i}.tp_loss(1),fwh{i}.tp_loss(2),...
            ['\DeltaP ',sprintf('-%.2f %%',ploss*100)],...
            'HorizontalAlignment','left',...
            'FontUnits','normalized','FontSize',cross_fontsize);
        
        txt_cell={txt_obj,[],[],[]};
        
        text_list.add(txt_cell);
    end

    % Heater line ploss
    pos_x=fwh{1}.Cold_out(1)-20;
    pos_y=fwh{1}.Cold_out(2)-3.5;
    other_txts.add({text(pos_x,pos_y,...
        ['HTR \DeltaP ',sprintf('-%.2f %%',cycle.HTR_ploss*100)],...
        'HorizontalAlignment','left',...
        'FontUnits','normalized','FontSize',cross_fontsize)});

    % Reheater loss
    pos_x=turHPIP.IP_in(1)-12;
    pos_y=turHPIP.HP_in(2)+5.3+3;
    other_txts.add({text(pos_x,pos_y,...
        ['RHTR \DeltaP ',sprintf('-%.2f %%',cycle.RHTR_ploss*100)],...
        'HorizontalAlignment','left',...
        'FontUnits','normalized','FontSize',cross_fontsize)});
end


% Set axis properties
if draw_text
ax.XLim=[-1,con.right_most+6];
else
    ax.XLim=[-1,con.right_most+2];
end
ax.YLim=[12,100];

% Units cross
if draw_text    
    cross(ax,[con.right_most-9,92],'bar','kg/s','kJ/kg','ºC',cross_fontsize);
end

% Set return objects
ax_obj=ax;
fwh_cords=fwh;
tur_cords={turHPIP.hp_corners, turHPIP.ip_corners, turLP.pos_corners};

%%%%% Rewrite text if cycle is already drawn
    function rewrite(cycle, c_list)
        
        c_list.reset_counter();
        
        % Turbine inlet and full out text
        cross(0, 0,...
            cycle.tur{1}.adm_EX(2),...
            cycle.m_fw,...
            cycle.tur{1}.adm_h(2),...
            cycle.tur{1}.T_st(1)-273,...
            0,c_list.get_next());
        
        % IP Turbine inlet before intercept Valve
        cross(0, 0,...
            cycle.tur{2}.adm_EX(1),...
            cycle.tur{2}.m_in,...
            cycle.tur{2}.adm_h(1),...
            cycle.tur{2}.adm_T(1)-273,...
            0,c_list.get_next());
        
        % IP Turbine inlet after intercept Valve
        cross(0, 0,...
            cycle.tur{2}.adm_EX(2),...
            cycle.tur{2}.m_in-cycle.tur{2}.m_Leaks.shft_nd(1),...
            cycle.tur{2}.adm_h(2),...
            cycle.tur{2}.adm_T(2)-273,...
            0,c_list.get_next());
        
        % LP Turbine inlet
        cross(0, 0,...
            cycle.tur{2}.EX(1,cycle.tur{2}.XO_pos),...
            cycle.tur{2}.m_in-sum(cycle.tur{2}.m_EX(1:cycle.tur{2}.XO_pos)),...
            cycle.tur{2}.h_st(cycle.tur{2}.XO_pos),...
            cycle.tur{2}.T_st(cycle.tur{2}.XO_pos)-273,...
            0,c_list.get_next());
        
        % LP Turbine exhaust
        cross(0, 0,...
            cycle.tur{1}.EX(1,end),...
            cycle.tur{1}.m_out+cycle.tur{1}.m_EX(end),...
            cycle.tur{1}.h_st(end),...
            cycle.tur{1}.T_st(end)-273,...
            0,c_list.get_next());
        
        % Extractions
        for ef=1:ex_HPT
            cross(0, 0,...
                cycle.tur{1}.EX(1,ef+1),...
                cycle.tur{1}.m_EX(ef+1),...
                cycle.tur{1}.h_st(ef+1),...
                cycle.tur{1}.T_st(ef+1)-273,...
                0,c_list.get_next());
        end
        
        for ef=1:fwh_hp+1-ex_HPT
            cross(0, 0,...
                cycle.tur{2}.EX(1,ef+1),...
                cycle.tur{2}.m_EX(ef+1),...
                cycle.tur{2}.h_st(ef+1),...
                cycle.tur{2}.T_st(ef+1)-273,...
                0,c_list.get_next());
        end
        
        for ef=1:fwh_lp
            cross(0, 0,...
                cycle.tur{2}.EX(1,ef+1+fwh_hp+1-ex_HPT),...
                cycle.tur{2}.m_EX(ef+1+fwh_hp+1-ex_HPT),...
                cycle.tur{2}.h_st(ef+1+fwh_hp+1-ex_HPT),...
                cycle.tur{2}.T_st(ef+1+fwh_hp+1-ex_HPT)-273,...
                0,c_list.get_next());
        end
        
        for ic=1:(fwh_hp+fwh_lp+1)
            
            % Position in fwh cell in cycle
            if ic<=fwh_hp
                posf=ic;
            else
                posf=ic-1;
            end
            
            if ic~=fwh_hp+1
                TTDf=cycle.fwh{posf}.TTD;
                DCAf=cycle.fwh{posf}.DCA;
                bypassf=cycle.fwh{posf}.bypass;
                
                % Special case
                if DCAf==-1
                    bypassf=1;
                end
                
                list=c_list.get_next();
                
                if bypassf==1
                    
                    list{1}.String='BYPASS';
                    list{1}.Color=[1,0,0];
                    list{1}.FontWeight='bold';
                    
                    list{2}.String='';
                else
                    % Rewrite TTD and DCA text
                    % TTD
                    string1 = ['TD ', num2str(TTDf,'%.2f')];
                    
                    % DCA
                    string2 = ['DA ', num2str(DCAf,'%.2f')];
                    
                    list{1}.String=string1;
                    list{1}.Color=[0,0,0];
                    list{1}.FontWeight='normal';
                    list{2}.String=string2;
                end
            end
            
            % FWH text
            if (ic<=fwh_hp) || (ic>fwh_hp+1)
                % FWHs
                if posf==fwh_hp+fwh_lp
                    cross(0, 0,...
                        cycle.fwh{posf}.P_C,...
                        cycle.fwh{posf}.mciclo,...
                        cycle.fwh{posf}.h_Cin,...
                        cycle.fwh{posf}.T_Cin-273,...
                        0,c_list.get_next());
                end
                
                
                cross(0, 0,...
                    cycle.fwh{posf}.P_C,...
                    cycle.fwh{posf}.mciclo,...
                    cycle.fwh{posf}.h_Cout,...
                    cycle.fwh{posf}.T_Cout-273,...
                    0,c_list.get_next());
                
                cross(0, 0,...
                    cycle.fwh{posf}.P_ex,...
                    cycle.fwh{posf}.md+cycle.fwh{posf}.mex,...
                    cycle.fwh{posf}.h_Hout,...
                    cycle.fwh{posf}.T_Hout-273,...
                    0,c_list.get_next());
                
                cross(0, 0,...
                    cycle.fwh{posf}.P_ex,...
                    cycle.fwh{posf}.mex,...
                    cycle.fwh{posf}.h_ex,...
                    cycle.fwh{posf}.T_Hin-273,...
                    0,c_list.get_next());
            else
                % Deareator
                cross(0, 0,...
                    cycle.P_COpmp,...
                    cycle.m_fw,...
                    cycle.h_DA_out,...
                    cycle.T_DA_out-273,...
                    0,c_list.get_next());
                
                cross(0, 0,...
                    cycle.P_COpmp,...
                    cycle.m_DA_mix,...
                    cycle.h_DA_mix,...
                    cycle.T_DA_mix-273,...
                    0,c_list.get_next());
                
                cross(0, 0,...
                    cycle.fw_pmp.P_out,...
                    cycle.fw_pmp.m_in,...
                    cycle.fw_pmp.h_out,...
                    cycle.fw_pmp.T_out-273,...
                    0,c_list.get_next());
                
            end
        end
        
        
        % Draw condenser, condenser pump and LP out
        cross(0,0,...
            cycle.tur{2}.EX(1,end),...
            cycle.tur{2}.m_out,...
            cycle.tur{2}.h_st(end),...
            cycle.tur{2}.T_st(end)-273,...
            0,c_list.get_next());
        
        cross(0, 0,...
            cycle.co_pmp.P_in,...
            cycle.co_pmp.m_in,...
            cycle.co_pmp.h_in,...
            cycle.co_pmp.T_in-273,...
            0,c_list.get_next());
        
        
        % Heater output
        cross(0, 0,...
            cycle.P_HTR,...
            cycle.m_fw,...
            cycle.tur{1}.adm_h(1),...
            cycle.T_HTR-273,...
            0,c_list.get_next());
        
        % Draw leakage mass flows
        leaks_draw(0, 0, cycle.tur{1}.m_Leaks,0,c_list.get_next());
        
        % Extraction lines loss
        for h=1:(fwh_hp+fwh_lp+1)

            if h==fwh_hp+1
                fploss=cycle.DAEX_ploss;
            elseif h<fwh_hp+1
                fploss=cycle.EX_ploss(h);
            else
                fploss=cycle.EX_ploss(h-1);
            end

            txt=c_list.get_next();
            txt{1}.String=['\DeltaP ',sprintf('-%.2f %%',fploss*100)];
            
        end
        
    end

end

